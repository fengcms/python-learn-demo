---
title: "Shell 从日志文件中选择时间段内的日志输出到另一个文件"
date: 2017-08-02 10:13:08 +0800
lastmod: 2017-08-02 10:13:08 +0800
author: fungleo
preview: "Shell从日志文件中选择时间段内的日志输出到另一个文件情况是这样的，某系统的日志全部写在一个日志文件内，所以这个文件非常大，非常长，每次查阅的时候非常的不方便。所以，相关人员希望能够查询某个时间段内的日志。我简单些了一个脚本来实现了这个效果。不过我的实现不是最佳方案，性能上还有很大的优化空间，但我目前水平有限，没有想到更好的方法。分析日志5074400:2017-08-01T01:34:22.7"
tags: ["shell", "优化", "性能", "脚本"]
categories:
    - Linux\CentOS
---

# Shell 从日志文件中选择时间段内的日志输出到另一个文件

情况是这样的，某系统的日志全部写在一个日志文件内，所以这个文件非常大，非常长，每次查阅的时候非常的不方便。所以，相关人员希望能够查询某个时间段内的日志。我简单些了一个脚本来实现了这个效果。

不过我的实现不是最佳方案，性能上还有很大的优化空间，但我目前水平有限，没有想到更好的方法。

## 分析日志

```
5074400:2017-08-01T01:34:22.724252+00:00 test_rest_1.test_default bpmn_test: [2017/08/01 09:34:22,723] trump.restapi preprocess: 8bc570ee765911e799070242ac120006 - GET profile:{}:None
```

日志内容如上，每一行的格式都差不多。里面有两个时间的参数，我决定取后面的这个时间的参数。想一下，应该很容易取到。

然后拿这个时间和我们设定的开始时间和结束时间进行比较，如果在时间段之内，则把这一行字符串插入到一个新的文件。

逻辑清晰，开始实现。

## 实现 shell 脚本

```
# 设定开始时间
s='2017/08/01 0:0:0'
# 设定结束时间
e='2017/08/01 24:0:0'
# 读取 3.log 这个原始文件，并且逐行循环
cat 3.log | while read line; do
  # 每读取一行，就在终端打一个#号，以便我知道这脚本还活着 :)
  # -n 是让 echo 的内容在前面追加，而不是换行
  # 在 mac 下面，用 sh log.sh 的方式运行会出错，不知道为什么
  # 换成 bash log.sh 则可以顺利运行
  echo -n "#"
  # 用 cut 方式取得每一行的时间，并赋予变量
  t=$(echo $line | cut -f 2 -d \[ | cut -f 1 -d \,)
  # 如果 t 在我们设定的时间段内
  if [[ "$t" > "$s" ]] && [[ "$t" < "$e" ]];
    # 则将改行追加到 new.log 文件
    then echo $line >> new.log
  fi
done
```

好，逻辑非常清晰的实现了这个脚本。但是遇到了脚本兼容性的问题。我没搞明白为什么 `sh log.sh` 运行方式下 `echo -n` 这个参数会出问题。但是在 `bash log.sh` 的情况下是按照我的理解正常输出的。

问了下同事，shell 兼容性问题是一个很常见的问题。

## 优化这个脚本

同事给出了一个新的语法，不甚理解，但是据说效率会提升很多。代码如下：

```
# 设定开始时间
s='2017/08/01 0:0:0'
# 设定结束时间
e='2017/08/01 24:0:0'
# 读取每一行循环
while read line; do
  # 每读取一行，就在终端打一个#号，以便我知道这脚本还活着 :)
  # -n 是让 echo 的内容在前面追加，而不是换行
  # 在 mac 下面，用 sh log.sh 的方式运行会出错，不知道为什么
  # 换成 bash log.sh 则可以顺利运行
  echo -n "#"
  # 用 cut 方式取得每一行的时间，并赋予变量
  t=$(echo $line | cut -f 2 -d \[ | cut -f 1 -d \,)
  # 如果 t 在我们设定的时间段内
  if [[ "$t" > "$s" ]] && [[ "$t" < "$e" ]];
    # 则将改行追加到 new.log 文件
    then echo $line >> new.log
  fi
# 3.log 作为参数传进来
done < 3.log
```
同事解释了一下原理，没听懂，但确实可以运行，并且效率有所提高。

## 2017年08月03日补充

上面循环的方法是在是太浪费时间了，所以换了一个思路，实现了同样的效果。参见 [Shell 命令行 从日志文件中根据将符合内容的日志输出到另一个文件](http://blog.csdn.net/FungLeo/article/details/76618875)

以上脚本均在 mac 下测试通过，在 linux 下可能会有稍许不同。

本文由 FungLeo 原创，允许转载，但转载必须保留首发链接。

